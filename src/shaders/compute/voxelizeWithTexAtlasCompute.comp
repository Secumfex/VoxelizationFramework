#version 430 core

// struct type of values accessed through vertex buffer
struct Vert{
	float x;
	float y;
	float z;
};

// specify local work group size 
layout (local_size_x = 1024) in;

// vertex buffer access
layout( std140, binding = 0 ) buffer destBuffer { Vert v[ ]; } vertices;

// voxel grid texture ( format MUST be single channel unsigned integer to make atomic operations work )
layout( r32ui, binding = 0 ) uniform uimage2D voxel_grid_texture;

// bit mask
layout( r32ui, binding = 1 ) uniform readonly uimage1D bitmaskTexture;

// texture atlas containing world positions
uniform sampler2D uniformTextureAtlas;

// matrix from world position to voxel grid coordinates
uniform mat4 uniformWorldToVoxel;

uniform int uniformNumVertices;

void main()
{
	// determine which vertex to read from
	uint gid = gl_GlobalInvocationID.x ;
	
	// read vertex data
	if ( gid > uniformNumVertices )
	{
		return;
	}
	
	Vert vertex = vertices.v[ gid ];
	
	// retrieve world position from texture atlas
	vec4 pos = texture( uniformTextureAtlas, vec2( vertex.x, vertex.y ) );
	
	// position in grid coordinates
	vec3 gridPos = ( uniformWorldToVoxel * pos ).xyz;
	
	// retrieve depth component
	int depth = int( gridPos.z );
	
	// abort if too far away
	if ( depth >= 32 || depth < 0 )
	{
		return;
	}
	
	// compute BYTE-value from depth value of grid position
	uvec4 bitMask = imageLoad( bitmaskTexture, depth );			
	uint  byte = bitMask.r ;	
		
	// retrieve x / y coordinates
	ivec2 gridSize = imageSize( voxel_grid_texture );
	int x = int( gridPos.x );
	int y = int( gridPos.y );
	ivec2 writeTo  = ivec2( x, y );
	
	// OR with byte currently written in voxel grid texture
	uint before = imageAtomicOr( voxel_grid_texture, writeTo , byte );
}